name: dbt status to Slack (Discovery API)

on:
  schedule:
    - cron: ""
  workflow_dispatch: {}

jobs:
  dbt-status-check:
    runs-on: ubuntu-latest
    env:
      DBT_DISCOVERY_URL: ${{ secrets.DBT_DISCOVERY_URL }}
      DBT_TOKEN: ${{ secrets.DBT_TOKEN }}
      DBT_JOB_IDS_CSV: ${{ secrets.DBT_JOB_IDS_CSV }}        # e.g. "12345,67890"
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
      SLACK_STATUS_TS: ${{ secrets.SLACK_STATUS_TS }}
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    steps:
      - uses: actions/checkout@v4

      - name: Query Discovery API for latest job runs
        id: check
        run: |
          set -euo pipefail
          python - << 'PY'
          import os, json, time, urllib.request, urllib.error

          discovery_url = os.environ["DBT_DISCOVERY_URL"]
          token         = os.environ["DBT_TOKEN"]
          job_ids       = [j.strip() for j in os.environ["DBT_JOB_IDS_CSV"].split(",") if j.strip()]

          # GraphQL query:
          # We ask for the most recent run (limit:1, sort desc) for each job ID.
          # Adjust field / arg names if your schema differs.
          #
          # Expected response shape:
          # {
          #   "data": {
          #     "jobRuns": [
          #        { "jobId": "12345", "status": "success", "finishedAt": "2025-10-27T01:23:45Z" },
          #        ...
          #     ]
          #   }
          # }
          #
          # status values we treat as success: "success", "completed"
          # anything else -> degraded

          gql_query = """
          query LatestJobRuns($jobIds: [ID!]!) {
            jobRuns(jobIds: $jobIds, limit: 1, orderBy: FINISHED_AT_DESC) {
              jobId
              status
              finishedAt
            }
          }
          """

          payload = {
              "query": gql_query,
              "variables": {
                  "jobIds": job_ids
              }
          }

          req = urllib.request.Request(
              discovery_url,
              data=json.dumps(payload).encode("utf-8"),
              headers={
                  "Authorization": f"Bearer {token}",
                  "Content-Type": "application/json",
              },
              method="POST",
          )

          try:
              with urllib.request.urlopen(req, timeout=30) as r:
                  raw = r.read().decode()
          except urllib.error.HTTPError as e:
              # bubble up a clean failure so we can see it in Slack
              raw = json.dumps({
                  "error": f"HTTP {e.code}",
                  "body": e.read().decode(errors="replace"),
              })

          # Parse
          try:
              resp = json.loads(raw)
          except json.JSONDecodeError:
              resp = {"error": "non-json response", "body": raw}

          runs = []
          any_bad = False
          debug_lines = []

          # Defensive parse
          data = resp.get("data", {})
          api_runs = data.get("jobRuns", [])

          # Build a dict {jobId: runInfo} because API may return multiple entries or none
          latest_by_job = {}
          for run in api_runs:
              jid   = str(run.get("jobId"))
              stat  = run.get("status")
              f_at  = run.get("finishedAt")
              # first (limit:1) should already be latest, but guard anyway:
              if jid not in latest_by_job:
                  latest_by_job[jid] = {"status": stat, "finishedAt": f_at}

          # Ensure we record something for every requested job ID
          for jid in job_ids:
              info = latest_by_job.get(jid)
              if info is None:
                  debug_lines.append(f"job {jid}: no run data")
                  any_bad = True
              else:
                  stat = info["status"]
                  f_at = info["finishedAt"]
                  debug_lines.append(f"job {jid}: status={stat} finished_at={f_at}")
                  norm = (stat or "").lower()
                  if norm not in ("success", "succeeded", "complete", "completed"):
                      any_bad = True

          overall = "Operational"
          if any_bad:
              overall = "Degraded"

          summary = f"dbt status: {overall}"
          detail  = "\\n".join(debug_lines)

          # surface internal API errors too (401 etc)
          if "error" in resp:
              overall = "Degraded"
              summary = f"dbt status: {overall} (discovery api error {resp['error']})"
              detail  = detail + "\\n[discovery_api_error]\\n" + json.dumps(resp, indent=2)[:800]

          # Emit outputs for downstream steps
          # set-output is deprecated but still works for simple multi-step jobs
          print(f"::set-output name=overall::{overall}")
          print(f"::set-output name=summary::{summary}")
          print(f"::set-output name=detail::{detail}")
          PY

      - name: Update pinned Slack status message
        run: |
          TEXT="${{ steps.check.outputs.summary }}\n(updated by GitHub Actions)"
          curl -X POST \
            -H "Content-type: application/json; charset=utf-8" \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            --data "{
              \"channel\": \"${SLACK_CHANNEL_ID}\",
              \"ts\": \"${SLACK_STATUS_TS}\",
              \"text\": \"${TEXT}\"
            }" \
            https://slack.com/api/chat.update

      - name: Send feed message
        run: |
          STATUS="${{ steps.check.outputs.overall }}"
          SUMMARY="${{ steps.check.outputs.summary }}"
          DETAIL="${{ steps.check.outputs.detail }}"
          if [ "$STATUS" = "Operational" ]; then
            ICON=":white_check_mark:"
          else
            ICON=":warning:"
          fi
          PAYLOAD=$(cat <<EOF
          {
            "text": "${ICON} ${SUMMARY}\n\`\`\`${DETAIL}\`\`\`"
          }
          EOF
          )
          curl -X POST \
            -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL"
